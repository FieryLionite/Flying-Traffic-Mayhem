<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>1</depth>
  <persistent>-1</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// store view size so we can use it further in aspect calculations.
_width = window_get_width();
_height = window_get_height();

// create simple vertex format definition.
vertex_format_begin();
vertex_format_add_position_3d();
_vfd = vertex_format_end();

// create sky dome vertex buffer.
// sky dome is just a box but camera perspective makes it looks like dome.
_vb = vertex_create_buffer();
vertex_begin(_vb, _vfd);

// now we write vertices of each side of box to vertex buffer.
// +x
vertex_position_3d(_vb, 1.0, 1.0, 1.0);
vertex_position_3d(_vb, 1.0, -1.0, 1.0);
vertex_position_3d(_vb, 1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, 1.0, -1.0);
vertex_position_3d(_vb, 1.0, 1.0, 1.0);
// +y
vertex_position_3d(_vb, 1.0, 1.0, 1.0);
vertex_position_3d(_vb, -1.0, 1.0, 1.0);
vertex_position_3d(_vb, -1.0, 1.0, -1.0);
vertex_position_3d(_vb, -1.0, 1.0, -1.0);
vertex_position_3d(_vb, 1.0, 1.0, -1.0);
vertex_position_3d(_vb, 1.0, 1.0, 1.0);
// +z
vertex_position_3d(_vb, -1.0, 1.0, 1.0);
vertex_position_3d(_vb, -1.0, -1.0, 1.0);
vertex_position_3d(_vb, 1.0, -1.0, 1.0);
vertex_position_3d(_vb, 1.0, -1.0, 1.0);
vertex_position_3d(_vb, 1.0, 1.0, 1.0);
vertex_position_3d(_vb, -1.0, 1.0, 1.0);
// -x
vertex_position_3d(_vb, -1.0, 1.0, 1.0);
vertex_position_3d(_vb, -1.0, -1.0, 1.0);
vertex_position_3d(_vb, -1.0, -1.0, -1.0);
vertex_position_3d(_vb, -1.0, -1.0, -1.0);
vertex_position_3d(_vb, -1.0, 1.0, -1.0);
vertex_position_3d(_vb, -1.0, 1.0, 1.0);
// -y
vertex_position_3d(_vb, 1.0, -1.0, 1.0);
vertex_position_3d(_vb, -1.0, -1.0, 1.0);
vertex_position_3d(_vb, -1.0, -1.0, -1.0);
vertex_position_3d(_vb, -1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, -1.0, 1.0);
// -z
vertex_position_3d(_vb, -1.0, 1.0, -1.0);
vertex_position_3d(_vb, -1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, -1.0, -1.0);
vertex_position_3d(_vb, 1.0, 1.0, -1.0);
vertex_position_3d(_vb, -1.0, 1.0, -1.0);

// end of writing vertices to vertex buffer and freeze it cause we do not add vertices further.
vertex_end(_vb);
vertex_freeze(_vb);
time = 8;
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
if(keyboard_check(vk_up))
    time += 0.1;
if(keyboard_check(vk_down))
    time -= 0.1;*/
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// initialize temporary variables.
var aspect, d, D, uSunPos, uSkyColor, uSkyColorRed, uSunColorYellow, uSunColorAura, uSunPosFactor, uSunHorFactor, uSunVertFactor, uPosHorFactor, sunTime, sunAlpha, sunBeta, sunX, sunY, sunZ;

// calculate view aspect.
aspect = _width / _height;

// calculate box diagonals.
d = sqrt(1.0 + (aspect * aspect));
D = sqrt(2.0 * (d * d));

// start 3d drawing mode (it just simplyfy turning on and off 3d camera mode that is needed to render sky dome correctly).
d3d_start();

// set camera projection on position {0, 0, 0} and looking toward positive X axis.
// we use 45 camera angle to imitate dome, and box diagonals for z-near and z-far.
d3d_set_projection_ext(0, 0, 0, 1, 0, 0, 0, 0, 1, 45, aspect, d * 0.5, D * 2.0);

// reset transformations.
d3d_transform_set_identity();

// add sky dome scalling (now dome will have the lowest box diagonal size).
d3d_transform_add_scaling(d, d, d);

// add rotation to correct view area.
d3d_transform_add_rotation_y(-22.5);

// obtain shader uniforms.
uSunPos = shader_get_uniform(fxAtmos, "uSunPos");
uSkyColor = shader_get_uniform(fxAtmos, "uSkyColor");
uSkyColorRed = shader_get_uniform(fxAtmos, "uSkyColorRed");
uSunColorYellow = shader_get_uniform(fxAtmos, "uSunColorYellow");
uSunColorAura = shader_get_uniform(fxAtmos, "uSunColorAura");
uSunPosFactor = shader_get_uniform(fxAtmos, "uSunPosFactor");
uSunHorFactor = shader_get_uniform(fxAtmos, "uSunHorFactor");
uSunVertFactor = shader_get_uniform(fxAtmos, "uSunVertFactor");
uPosHorFactor = shader_get_uniform(fxAtmos, "uPosHorFactor");

// calculate sun position.
sunTime = time;//current_time * 0.0001;
sunAlpha = sin(sunTime) * 20.0;
sunBeta = cos(sunTime) * 40.0;
sunX = cos(degtorad(sunAlpha)) * cos(degtorad(sunBeta));
sunY = sin(degtorad(sunAlpha)) * cos(degtorad(sunBeta));
sunZ = sin(degtorad(sunBeta));

// bind shader.
shader_set(fxAtmos);

// send uniforms to shader program.
shader_set_uniform_f(uSunPos, sunX, sunY, sunZ);
shader_set_uniform_f(
    uSkyColor,
    0.42745098039215686274509803921569,
    0.51372549019607843137254901960784,
    0.85490196078431372549019607843137
);
shader_set_uniform_f(uSkyColorRed, 1.0, 0.5, 0.0);
shader_set_uniform_f(uSunColorYellow, 1.0, 1.0, 0.0);
shader_set_uniform_f(uSunColorAura, 1.0, 1.0, 0.25);
shader_set_uniform_f(uSunPosFactor, 100.0);
shader_set_uniform_f(uSunHorFactor, 20.0);
shader_set_uniform_f(uSunVertFactor, 10.0);
shader_set_uniform_f(uPosHorFactor, 30.0);

// draw sky dome without base texture.
vertex_submit(_vb, pr_trianglelist, -1);

// reset to main shader.
shader_reset();

// end of 3d mode (GM will now restore orthographic projection so we can continue drawing graphics in default 2d mode).
d3d_set_projection_ortho(view_xview[0], view_yview[0], view_wview[0], view_hview[0], 0);
d3d_transform_set_scaling(1,1,1);
d3d_end();

//draw_set_color(c_black);
//draw_text(100,100 ,string(sunTime));
    draw_sprite(sprTower, 0, room_width/2, room_height);
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="9" enumb="113">
      <action>
        <libid>1</libid>
        <id>802</id>
        <kind>0</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>0</useapplyto>
        <exetype>1</exetype>
        <functionname>action_snapshot</functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>2</kind>
            <string>snapshot.png</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
